# 01 📚 기본형 데이터와 참조형 데이터

<br>

## 📝 읽은 내용

### 불변값
- 불변값(Immutable Value): 데이터 자체가 변경되지 않는 값
- 상수(Constant): 변수의 메모리 주소(참조)가 변경되지 않는 값

> 상수와 불변성은 같은 개념인가?
> 상수는 변수의 재할당을 막는 개념, 즉, 변수에 저장된 메모리 주소를 변경할 수 없다.
> 불변값은 데이터 자체가 변경되지 않는 값, 예를 들어, 문자열 혹은 숫자

```js
var a = 'abc';
a = a + 'def';

var b= 5;
var c = 5;
```
- `a = a = 'def'`라 해서 기존의 'abc'가 변하는 것이 아니라 새로운 문자열 'abcdef'를 만들어 그 주소를 변수 a에 저장한다.
- `b`에서 사용한 `5`를 `c`에 할당할 때, 이미 만들어 놓은 데이터의 주소를 재활용하여 사용한다.

### 참조형 데이터의 메모리 할당
```js
var obj1 = {
  a: 1,
  b: 'bbb',
}
```
1. 변수 영역
   
| 주소  | ... | 1002                   | 1003 | 1004 | 1005 | ... |
|-------|-----|------------------------|------|------|------|-----|
| 데이터|     | 이름: **obj1** / 값: @7103,  @7104    |      |      |      |     |

2. 데이터 영역
   
| 주소  | ... | 5002 | 5003 | 5004 | 5005 | ... |
|-------|-----|------|------|------|------|-----|
| 데이터|     | 값: @7103 ~ ?     |      | **1**| **'bbb'**     |     |

3. 객체의 변수(프로퍼티) 영역
   
| 주소  | ... | 7103 | 7104 | 7105 | 7106 | ... |
|-------|-----|------|------|------|------|-----|
| 데이터|     | 이름:**a** / 값: @5004     |  이름:**b** / 값: @5005     | |    |     |

- 객체는 변수와 달리 **객체의 변수(프로퍼티) 영역**이 별도로 존재한다.
- 객체는 데이터 영역에 저장된 값은 모두 불변값이다.
- 그러나, 변수(프로퍼티)에는 다른 값을 얼마든지 대입할 수 있다.
- 바로 이 부분이 참조형 데이터는 불변하지 않다 라고 한다. (혹은 가변값이다)


### 중첩 객체
참조형 데이터의 프로퍼티에 다시 참조형 데이터를 할당하는 경우를 **중첩 객체(nested object)** 라고 한다.

```js
var obj = {
  x: 3,
  arr: [ 3, 4, 5 ]
};
```
1. 변수 영역
   
| 주소  | ... | 1002  | 1003  | 1004  | 1005  | ... |
|-------|-----|-------|-------|-------|------|-----|
| 데이터 |     | 이름: **obj** / 값: @7201 |       |       |      |     |

2. 데이터 영역
   
| 주소  | ... | 5002  | 5003  | 5004  | 5005  | 5006  | ... |
|-------|-----|-------|-------|-------|-------|------|-----|
| 데이터 |     | 값: @7201 ~ ? |       | **3** | **배열(@7301)** |      |     |

3. 객체의 변수(프로퍼티) 영역
   
| 주소  | ... | 7201  | 7202  | 7203  | 7204  | ... |
|-------|-----|-------|-------|-------|-------|-----|
| 데이터 |     | 이름: **x** / 값: @5004 | 이름: **arr** / 값: @7301 |      |       |

4. 배열의 변수(인덱스) 영역
   
| 주소  | ... | 7301  | 7302  | 7303  | 7304  | ... |
|-------|-----|-------|-------|-------|-------|-----|
| 데이터 |     | 이름: **0** / 값: @5004 | 이름: **1** / 값: @5005 | 이름: **2** / 값: @5006 |       |     |

5. 배열의 데이터 영역
   
| 주소  | ... | 5004  | 5005  | 5006  | ... |
|-------|-----|-------|-------|-------|-----|
| 데이터 |     | **3** | **4** | **5** |     |

- 중첩 객체라 할지라도 마찬가지로 중첩된 객체의 프로퍼티와 프로퍼티의 데이터 영역을 따로 분리하여 메모리 구조를 만든다.
- 이 상태에서 `obj.arr[1]`을 검색하는 과정은 아래와 같다.
   - `@1002 => @5002 => (@7103 ~ ?) => @7104 => @5003 => (@8104 ~ ?) => @8105 => @5004 => 4반환`

<br>

```js
obj.arr = 'str';
```

- 이미 배열이 할당되어있는 프로퍼티에 재할당을 하게되면 어떻게 될까?
- 4번과 5번 메모리는 3번 메모리에서 해제되고 새로운 메모리 주소에 'str'을 할당하게 될 것이다.
- 4번과 5번 메모리는 GC컬렉터 대상이되어 수거되고 수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈 공간된다.

<br>

### 변수 복사 비교

기본형 데이터의 변수를 복사하는 경우

```js
var a = 10;
var b = a;
```
1. 변수 영역
   
| 주소  | ... | 7301  | 7302  | 7303  | 7304  | ... |
|-------|-----|-------|-------|-------|-------|-----|
| 데이터 |     | 이름: **a** / 값: @5004 | 이름: **b** / 값: @5004 |  |       |     |

2. 데이터 영역
   
| 주소  | ... | 5004  | 5005  | 5006  | ... |
|-------|-----|-------|-------|-------|-----|
| 데이터 |     | **10** |  |  |     |

- 변수를 선언하면서 변수 영역에 식별자와 데이터 영역의 주소가 저장된다.
- 해당 변수를 복사할 경우 변수의 식별자가 아닌 값(메모리 주소)를 복사한다.

<br>

참조형 데이터의 객체를 복사하는 경우

```js
var obj1 = { c: 10, d: 'ddd' };
var obj2 = obj1;
```

1. 객체 영역
   
| 주소  | ... | 1002                   | 1003 | 1004 | 1005 | ... |
|-------|-----|------------------------|------|------|------|-----|
| 데이터|     | 이름: **obj1** / 값: @7103 ~ ?    |  이름: **obj2** / 값: @7103 ~ ?    |      |      |     |

2. 프로퍼티 영역

| 주소  | ... | 7301  | 7302  | 7303  | 7304  | ... |
|-------|-----|-------|-------|-------|-------|-----|
| 데이터 |     | 이름: **c** / 값: @5004 | 이름: **d** / 값: @5005 |  |       |     |

3. 데이터 영역
   
| 주소  | ... | 5004  | 5005  | 5006  | ... |
|-------|-----|-------|-------|-------|-----|
| 데이터 |     | **10** | **'ddd'** |  |     |

- 주소를 모두 복사하는 점 기본형과 같다.
- 하지만, 값을 변경할 경우 차이가 생긴다.

### 복사한 값을 변경할 경우
```js
var obj1 = { c: 10, d: 'ddd' };
var obj2 = obj1;

obj2.c = 11;
obj2.d = 'ccc';
```

1. 객체 영역
   
| 주소  | ... | 1002                   | 1003 | 1004 | 1005 | ... |
|-------|-----|------------------------|------|------|------|-----|
| 데이터|     | 이름: **obj1** / 값: @7103 ~ ?    |  이름: **obj2** / 값: @7103 ~ ?    |      |      |     |

2. 프로퍼티 영역

| 주소  | ... | 7301  | 7302  | 7303  | 7304  | ... |
|-------|-----|-------|-------|-------|-------|-----|
| 데이터 |     | 이름: **c** / 값: @5004 => @5006 | 이름: **d** / 값: @5005 => @5007 |  |       |     |

3. 데이터 영역
   
| 주소  | ... | 5004  | 5005  | 5006  | 5007 |
|-------|-----|-------|-------|-------|-----|
| 데이터 |     | **10** | **'ddd'** | **11** |  **'ccc'** |

- `obj2.c`, `obj2.d`의 값들을 새로 할당했다. 즉, 프로퍼티들이 새로 할당된 것이다.
- 프로퍼티의 참조값은 바뀌었지만, 객체의 참조값은 변하지 않았다.
- `obj1`은 프로퍼티를 변경하지 않았지만, `obj2`와 동일한 객체를 참조하기 때문에 `obj2`가 바꾼 프로퍼티의 참조값을 따라간다.
- 이를 `얕은 복사`라 하고 값을 공유한다라고도 한다.

## 💡 인사이트
- 일반적으로는 참조형 데이터만 메모리주소를 참조하는 것처럼 많이들 말하지만, 이는 정확한 사실이 아니다.
- 코어자바스크립트 저자는 초심자가 이해하기에 어렵기 때문에 둘을 분리한 것이라고 한다.
- 하지만 중급 개발자로 성장하기 위해서는 명확한 내부 원리를 이해해야 한다.
- 표를 그리면서 객체와 프로퍼티의 참조가 어떻게 변화하는지 확인하여 더욱 잘 이해할 수 있었다.
